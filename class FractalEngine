class FractalEngine:
    def generate_mandelbrot(self, w, h, x_bounds, y_bounds, max_iter):
        x = np.linspace(x_bounds[0], x_bounds[1], w)
        y = np.linspace(y_bounds[0], y_bounds[1], h)
        c = x + y[:, None] * 1j
        z = np.zeros_like(c)
        counts = np.zeros(c.shape, dtype=float)
        mask = np.full(c.shape, True, dtype=bool)
        
        for i in range(max_iter):
            z[mask] = z[mask]**2 + c[mask]
            diverged = np.abs(z) > 2
            escaping_now = diverged & mask
            if np.any(escaping_now):
                # Формула для гладких переходів кольору
                z_abs = np.abs(z[escaping_now])
                counts[escaping_now] = i + 1 - np.log2(np.log2(z_abs))
            mask[diverged] = False
            if not np.any(mask): break
        return counts

    def generate_julia(self, w, h, x_bounds, y_bounds, c_const, max_iter):
        x = np.linspace(x_bounds[0], x_bounds[1], w)
        y = np.linspace(y_bounds[0], y_bounds[1], h)
        z = x + y[:, None] * 1j
        counts = np.zeros(z.shape, dtype=float)
        mask = np.full(z.shape, True, dtype=bool)
        
        for i in range(max_iter):
            z[mask] = z[mask]**2 + c_const
            diverged = np.abs(z) > 2
            escaping_now = diverged & mask
            if np.any(escaping_now):
                z_abs = np.abs(z[escaping_now])
                counts[escaping_now] = i + 1 - np.log2(np.log2(z_abs))
            mask[diverged] = False
            if not np.any(mask): break
        return counts
